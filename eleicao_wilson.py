# -*- coding: utf-8 -*-
"""Eleicao - Wilson.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fodPwlWUTd4EyzSjapYu23B-ADPlSVFf

# Etapa 1: Importação das bibliotecas
"""

import tensorflow as tf
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense, Dropout
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report
from keras.utils import np_utils
from sklearn.preprocessing import LabelEncoder
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os

"""# Etapa 2: Carregamento e exploração da base de dados

## Ler base da dados
"""

from google.colab import drive
drive.mount('/content/drive')

# Alterado o encoding do csv de candidatos para que os acentos e caracteres especiais fosse lido corretamente.
candidatos = pd.read_csv('/content/drive/MyDrive/Wilson Pessanha Campinho - consulta_cand_2020_RJ.csv',sep=';', encoding='ISO-8859-1')
receitas = pd.read_csv('/content/drive/MyDrive/Wilson Pessanha Campinho - receitas_candidatos_2020_RJ.csv',sep=';',encoding = "ISO-8859-1")
despesas = pd.read_csv('/content/drive/MyDrive/Wilson Pessanha Campinho - despesas_contratadas_candidatos_2020_RJ.csv',sep=';',encoding = "ISO-8859-1")

candidatos.info()

receitas.info()

despesas.info()

candidatos.columns

#deletar colunas
columns_to_remove = ['CD_SITUACAO_CANDIDATO_PLEITO',
 'CD_SITUACAO_CANDIDATO_URNA',
 'DS_SITUACAO_CANDIDATO_PLEITO',
 'DS_SITUACAO_CANDIDATO_URNA',
 'NM_URNA_CANDIDATO',
 'NR_PROCESSO',
 'NR_PROTOCOLO_CANDIDATURA',
 'SG_PARTIDO',
 'ST_CANDIDATO_INSERIDO_URNA',
 'ST_DECLARAR_BENS',
 'ST_REELEICAO',
 'VR_DESPESA_MAX_CAMPANHA']

candidatos = candidatos.drop(columns=columns_to_remove)

candidatos.columns

"""##Carregar apenas os dados do Municipio pelo Cargo

###Criação variavel para cargo e Municipio
"""

cargo = 'DS_CARGO'
municipio = 'NM_UE'

"""Criar Dataframe com somente Candidatos de Campos"""

# Canditados de Campos 
df_canditado_mun = candidatos[(candidatos[municipio] == "CAMPOS DOS GOYTACAZES") & (candidatos[cargo] == "VEREADOR")]
df_canditado_mun

# receitas de Canditados de Campos
df_receita_mun = receitas[(receitas[municipio] == "CAMPOS DOS GOYTACAZES") & (receitas[cargo] == "Vereador")]
df_receita_mun

# Despess de Canditados de Campos
df_despesa_mun = despesas[(despesas[municipio] == "CAMPOS DOS GOYTACAZES") & (despesas[cargo] == "Vereador")]
df_despesa_mun

"""## Determinar o valor total que cada Candidato  de receita e despesa contratada"""

df_receita_mun['VR_RECEITA'] = df_receita_mun['VR_RECEITA'].apply(lambda x: float(x.split()[0].replace(',', '.')))
df_despesa_mun['VR_DESPESA_CONTRATADA'] = df_despesa_mun['VR_DESPESA_CONTRATADA'].apply(lambda x: float(x.split()[0].replace(',', '.')))

# total receita por candidato
soma_cand_receita = df_receita_mun.groupby('NR_CPF_CANDIDATO')['VR_RECEITA'].sum()
soma_cand_receita

#total despesa por Candidato
soma_cand_despesa = df_despesa_mun.groupby('NR_CPF_CANDIDATO')['VR_DESPESA_CONTRATADA'].sum()
soma_cand_despesa

#cria um dataFrame com a juncao de todos os dados
candidatos_dataframe_receita = pd.merge(soma_cand_despesa, soma_cand_receita, on=['NR_CPF_CANDIDATO'])
df_candidatos = pd.merge(candidatos, candidatos_dataframe_receita, on=['NR_CPF_CANDIDATO'])
df_candidatos.head()

"""# Limpando os dados da situação da eleição.
Primeiro é levantado todos os valores presentes no campo de situação do candidato no turno da eleição. 

Em seguida, com esses dados, é feito uma limpeza na base de dados de forma a ser ter apenas a informação de que o candidato foi eleito ou não.

Por fim, é criado um dataframe auxiliar apenas com os candidatos eleitos que será utilizado no futuro para treinar o modelo.
"""

df_candidatos.DS_SIT_TOT_TURNO.unique()

ds_eleito = ['ELEITO POR QP', 'ELEITO POR MÉDIA']
df_candidatos.loc[df_candidatos.DS_SIT_TOT_TURNO.isin(ds_eleito), 'DS_SIT_TOT_TURNO'] = 'ELEITO'

ds_nao_eleito = ['#NULO#', '2º TURNO', 'NÃO ELEITO', 'SUPLENTE']
df_candidatos.loc[df_candidatos.DS_SIT_TOT_TURNO.isin(ds_nao_eleito), 'DS_SIT_TOT_TURNO'] = 'NAO_ELEITO'

custom_df = df_candidatos.query("DS_SIT_TOT_TURNO == 'ELEITO'")
custom_df.info

"""# Análise Exploratória dos Dados"""

# Análise para a idade dos candidatos
df_candidatos.NR_IDADE_DATA_POSSE.hist()

# Análise para a idade dos candidatos eleitos
custom_df = df_candidatos.query("DS_SIT_TOT_TURNO == 'ELEITO'")
sns.catplot(x="NR_IDADE_DATA_POSSE", data=custom_df, kind="count")

# Análise para o sexo do candidatos.
sns.catplot(x="DS_GENERO", data=df_candidatos, kind="count")

# Análise para o sexo dos candidatos eleitos
custom_df = df_candidatos.query("DS_SIT_TOT_TURNO == 'ELEITO'")
sns.catplot(x="DS_GENERO", data=custom_df, kind="count")

# Analisando as despesas.
print(df_candidatos.VR_DESPESA_CONTRATADA.describe())

# Exibindo a distribuição de despesas.
df_candidatos.VR_DESPESA_CONTRATADA.hist(bins=100)

# Analisando as receitas.
print(df_candidatos.VR_RECEITA.describe())

# Exibindo a distribuição de receitas.
df_candidatos.VR_RECEITA.hist(bins=100)

# Análise para a raça/etnia dos candidatos
print(df_candidatos.DS_COR_RACA.describe())

# Exibindo as raça/etnias .
df_candidatos.DS_COR_RACA.hist(bins=100)

# Análise para a raça/etnia dos candidatos eleitos

custom_df = df_candidatos.query("DS_SIT_TOT_TURNO == 'ELEITO'")
sns.catplot(x="DS_COR_RACA", data=custom_df, kind="count")

# Análise para o partido dos candidatos
print("Partidos: ", df_candidatos.NM_PARTIDO.nunique())

partidos_eleitos = df_candidatos[df_candidatos["DS_SIT_TOT_TURNO"] == 'ELEITO'].NM_PARTIDO.value_counts().keys().tolist()

print("Partidos eleitos: ", partidos_eleitos)

result_partidos = df_candidatos.loc[df_candidatos["DS_SIT_TOT_TURNO"] == 'ELEITO', "NM_PARTIDO"].value_counts()

result_partidos.plot.pie()

# Análise para o partido dos candidatos
print("Partidos: ", df_candidatos.NM_PARTIDO.nunique())

partidos_eleitos = df_candidatos[df_candidatos["DS_SIT_TOT_TURNO"] == 'ELEITO'].NM_PARTIDO.value_counts().keys().tolist()

print("Partidos eleitos: ", partidos_eleitos)

result_partidos = df_candidatos.loc[df_candidatos["DS_SIT_TOT_TURNO"] == 'ELEITO', "NM_PARTIDO"].value_counts()

result_partidos.plot.pie()

# Análise para o grau de instrução.
sns.catplot(x="DS_GRAU_INSTRUCAO", data=df_candidatos, kind="count")

# Análise para a escolaridade dos candidatos eleitos

custom_df = df_candidatos.query("DS_SIT_TOT_TURNO == 'ELEITO'")
sns.catplot(x="DS_GRAU_INSTRUCAO", data=custom_df, kind="count")

"""Com essa análise de dados é possível observar uma tendência dos vereadores eleitos na cidade de Campos serem **Homens**, em sua grande maioria **Empresários** possuindo uma **receita** média de **9185 reais** e **despesa** média de **6139 reais**.

# Preparação dos dados

Durante a preparação dos dados, a base de dados foi dividido em duas.



*   df_candidatos_situacao: que possui apenas as situações dos candidatos (eleito ou não eleito) que é o objetivo da previsão.
*   df_candidatos: que possui algumas colunas analisadas acima que na minha visão influencia no desempenho de um candidato, como por exemplo, os gastos dele durante a campanha, idade e escolaridade.


Foi necessário também mapear alguns dados categóricos para numéricos a fim de facilitar o treinamento do modelo.
"""

df_candidatos_situacao = df_candidatos[['DS_SIT_TOT_TURNO']]
df_candidatos_situacao

df_candidatos = df_candidatos[['NR_IDADE_DATA_POSSE','DS_GENERO','VR_DESPESA_CONTRATADA','VR_RECEITA','DS_COR_RACA','DS_GRAU_INSTRUCAO']]
df_candidatos

# Mapeando colunas categóricas

df = df_candidatos
mapping_genero = {'MASCULINO': 1, 'FEMININO': 2}
mapping_raca = {'PRETA': 1, 'BRANCA': 2, 'PARDA': 3, 'NÃO INFORMADO': 4, 'INDÍGENA': 5, 'AMARELA': 6}
mapping_instrucao = {'ENSINO FUNDAMENTAL INCOMPLETO': 1, 'SUPERIOR COMPLETO': 2, 'ENSINO MÉDIO INCOMPLETO': 3, 'ENSINO MÉDIO COMPLETO': 4, 'ENSINO FUNDAMENTAL COMPLETO': 5, 'LÊ E ESCREVE': 6, 'SUPERIOR INCOMPLETO': 7}
df['DS_GENERO'] = df['DS_GENERO'].apply(lambda x: mapping_genero[x])
df['DS_COR_RACA'] = df['DS_COR_RACA'].apply(lambda x: mapping_raca[x])
df['DS_GRAU_INSTRUCAO'] = df['DS_GRAU_INSTRUCAO'].apply(lambda x: mapping_instrucao[x])
df

# Mapeando colunas categóricas da situação do candidato (eleito / não eleito)
df_situacao = df_candidatos_situacao
mapping_situacao = {'ELEITO': 1, 'NAO_ELEITO': 0, 'SUPLENTE': 2}
df_situacao['DS_SIT_TOT_TURNO'] = df_situacao['DS_SIT_TOT_TURNO'].apply(lambda x: mapping_situacao[x])
df_situacao

# Obtendo apenas os indices e valores do dataframe

df_situacao_mapeada = df_situacao.copy();
df_situacao_mapeada = df_situacao_mapeada['DS_SIT_TOT_TURNO']
df_situacao_mapeada

# Obtendo apenas os indices e valores do dataframe
df_mapeada = df.copy();
df_mapeada = df_mapeada[['NR_IDADE_DATA_POSSE','DS_GENERO','VR_DESPESA_CONTRATADA','VR_RECEITA','DS_COR_RACA','DS_GRAU_INSTRUCAO']]

# Normalizando os valores do dataframe
df_mapeada_normalizada = df_mapeada.copy()
mms = MinMaxScaler()
df_mapeada_normalizada[df_mapeada_normalizada.columns] = mms.fit_transform(df_mapeada_normalizada[df_mapeada_normalizada.columns])
df_mapeada_normalizada

reshape = [
  [1, 0, 0],
  [0, 1, 0],
  [0, 0, 1],
]

df_situacao_mapeada_reshaped = df_situacao_mapeada.copy().apply(lambda x: reshape[x])
df_situacao_mapeada_reshaped.shape

reshape_array = [y for x in df_situacao_mapeada_reshaped for y in x]

situacao_final = np.asarray(reshape_array).reshape((-1,3))
situacao_final

candidatos_final = np.array(df_mapeada_normalizada, dtype='float32')

X_train, X_test, Y_train, Y_test = train_test_split(candidatos_final, situacao_final, test_size=0.3)

"""# Arquitetura da Rede Neural"""

checkpoint_dir = '/content/drive/MyDrive/Colab Notebooks/checkpoints'
checkpoint_prefix = os.path.join(checkpoint_dir, 'checkpoint_{epoch}')
checkpoint_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_prefix, save_weights_only=True)

def build_model():
  model = Sequential()

  model.add(Dense(256, activation='relu', input_shape=(6,)))
  model.add(Dropout(.2))
  model.add(Dense(16))
  model.add(Dense(3, activation='softmax'))

  return model

model = build_model()
model.compile(loss='mse',optimizer='adam',metrics=['accuracy'])

# Commented out IPython magic to ensure Python compatibility.
# %%time
# epochs = 45
# history = model.fit(X_train, Y_train, epochs=epochs, callbacks=[checkpoint_callback])

"""# Acurácia do modelo"""

accuracy = model.evaluate(X_test, Y_test)

"""# Previsão de dados"""

previsao = model.predict(X_test)
previsao

previsao_normalizada = np.argmax(np.array(previsao), axis=1)
previsao_normalizada

dado_esperado = np.argmax(Y_test, axis=1)
dado_esperado

# Imprimir o relatório final do modelo, 0 é a precisão para candidatos não eleitos e 1 para candidatos eleitos.
print(classification_report(dado_esperado, previsao_normalizada))

"""# Conclusão

O modelo ao final obteve uma taxa de precisão aceitável, apesar de ter tentado adicionar novas camadas a rede não fui capaz de melhorar essa precisão. De qualquer forma, o modelo consegue prever situações de candidatos nas eleições.

Talvez usando mais informações como por exemplo, a profissão do candidato pode-se conseguir uma precisão melhor nas previsões.
"""